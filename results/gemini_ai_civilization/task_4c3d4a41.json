{
  "task_id": "4c3d4a41",
  "success": true,
  "timestamp": "2025-11-01T17:50:36.773194+00:00",
  "config": {
    "max_generations": 3,
    "target_fitness": null,
    "sandbox_mode": "multiprocess",
    "model_name": "gemini-2.5-flash-lite",
    "programmer_temperature": 0.3,
    "refiner_temperature": 0.4,
    "timeout_eval": 5,
    "timeout_llm": 60,
    "use_cache": true,
    "use_analyst": true,
    "analyst_temperature": null,
    "use_tagger": true,
    "tagger_temperature": null,
    "use_crossover": false,
    "crossover_temperature": null
  },
  "generations": [
    {
      "generation": 0,
      "solver_code": "import numpy as np\n\ndef solve(task_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Shifts non-zero elements of each row to the left, preserving relative vertical positions.\n\n    Args:\n        task_grid: A numpy ndarray representing the input grid.\n\n    Returns:\n        A numpy ndarray representing the transformed grid.\n    \"\"\"\n    if task_grid.size == 0:\n        return task_grid\n\n    transformed_grid = np.zeros_like(task_grid)\n\n    for r_idx, row in enumerate(task_grid):\n        non_zero_indices = np.nonzero(row)[0]\n        non_zero_elements = row[non_zero_indices]\n        \n        # Determine the number of zeros to pad at the end\n        num_zeros_to_pad = task_grid.shape[1] - len(non_zero_elements)\n        \n        # Construct the new row\n        new_row = np.concatenate((non_zero_elements, np.zeros(num_zeros_to_pad, dtype=row.dtype)))\n        transformed_grid[r_idx] = new_row\n\n    return transformed_grid",
      "fitness_result": {
        "fitness": 0,
        "train_correct": 0,
        "train_total": 2,
        "test_correct": 0,
        "test_total": 2,
        "train_accuracy": 0.0,
        "test_accuracy": 0.0,
        "execution_errors": [],
        "error_details": [
          {
            "example_id": "train_0",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          },
          {
            "example_id": "train_1",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          },
          {
            "example_id": "test_0",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          },
          {
            "example_id": "test_1",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          }
        ],
        "error_summary": {
          "logic": 4
        }
      },
      "refinement_count": 0,
      "total_time": 3.136589765548706,
      "improvement": 0.0
    },
    {
      "generation": 1,
      "solver_code": "import numpy as np\n\ndef solve(task_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Shifts non-zero elements of each row to the left, preserving relative vertical positions.\n\n    Args:\n        task_grid: A numpy ndarray representing the input grid.\n\n    Returns:\n        A numpy ndarray representing the transformed grid.\n    \"\"\"\n    if task_grid.size == 0:\n        return task_grid\n\n    transformed_grid = np.zeros_like(task_grid)\n\n    for r_idx, row in enumerate(task_grid):\n        # Find the indices of non-zero elements in the current row\n        non_zero_indices = np.nonzero(row)[0]\n        \n        # Extract the non-zero elements themselves\n        non_zero_elements = row[non_zero_indices]\n        \n        # Calculate how many zeros are needed to fill the rest of the row\n        num_zeros_to_pad = task_grid.shape[1] - len(non_zero_elements)\n        \n        # Create the new row by concatenating the non-zero elements with the padding zeros\n        # Ensure the dtype of the zeros matches the original row's dtype\n        new_row = np.concatenate((non_zero_elements, np.zeros(num_zeros_to_pad, dtype=row.dtype)))\n        \n        # Assign the newly constructed row to the corresponding row in the transformed grid\n        transformed_grid[r_idx] = new_row\n\n    return transformed_grid",
      "fitness_result": {
        "fitness": 0,
        "train_correct": 0,
        "train_total": 2,
        "test_correct": 0,
        "test_total": 2,
        "train_accuracy": 0.0,
        "test_accuracy": 0.0,
        "execution_errors": [],
        "error_details": [
          {
            "example_id": "train_0",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          },
          {
            "example_id": "train_1",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          },
          {
            "example_id": "test_0",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          },
          {
            "example_id": "test_1",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          }
        ],
        "error_summary": {
          "logic": 4
        }
      },
      "refinement_count": 1,
      "total_time": 2.9013147354125977,
      "improvement": 0.0
    },
    {
      "generation": 2,
      "solver_code": "import numpy as np\n\ndef solve(task_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Shifts non-zero elements of each row to the left, preserving relative vertical positions.\n\n    Args:\n        task_grid: A numpy ndarray representing the input grid.\n\n    Returns:\n        A numpy ndarray representing the transformed grid.\n    \"\"\"\n    if task_grid.size == 0:\n        return task_grid\n\n    rows, cols = task_grid.shape\n    transformed_grid = np.zeros_like(task_grid)\n\n    for r_idx in range(rows):\n        row = task_grid[r_idx]\n        # Find the indices of non-zero elements in the current row\n        non_zero_mask = row != 0\n        \n        # Extract the non-zero elements themselves\n        non_zero_elements = row[non_zero_mask]\n        \n        # Calculate how many zeros are needed to fill the rest of the row\n        num_non_zeros = non_zero_elements.shape[0]\n        num_zeros_to_pad = cols - num_non_zeros\n        \n        # Create the new row by concatenating the non-zero elements with the padding zeros\n        # Ensure the dtype of the zeros matches the original row's dtype\n        new_row = np.concatenate((non_zero_elements, np.zeros(num_zeros_to_pad, dtype=row.dtype)))\n        \n        # Assign the newly constructed row to the corresponding row in the transformed grid\n        transformed_grid[r_idx] = new_row\n\n    return transformed_grid",
      "fitness_result": {
        "fitness": 0,
        "train_correct": 0,
        "train_total": 2,
        "test_correct": 0,
        "test_total": 2,
        "train_accuracy": 0.0,
        "test_accuracy": 0.0,
        "execution_errors": [],
        "error_details": [
          {
            "example_id": "train_0",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          },
          {
            "example_id": "train_1",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          },
          {
            "example_id": "test_0",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          },
          {
            "example_id": "test_1",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          }
        ],
        "error_summary": {
          "logic": 4
        }
      },
      "refinement_count": 1,
      "total_time": 3.4866161346435547,
      "improvement": 0.0
    }
  ],
  "final_fitness": 0,
  "total_generations": 3,
  "total_time": 9.524520635604858
}
