{
  "task_id": "28a6681f",
  "success": true,
  "timestamp": "2025-11-01T17:51:26.614093+00:00",
  "config": {
    "max_generations": 3,
    "target_fitness": null,
    "sandbox_mode": "multiprocess",
    "model_name": "gemini-2.5-flash-lite",
    "programmer_temperature": 0.3,
    "refiner_temperature": 0.4,
    "timeout_eval": 5,
    "timeout_llm": 60,
    "use_cache": true,
    "use_analyst": true,
    "analyst_temperature": null,
    "use_tagger": true,
    "tagger_temperature": null,
    "use_crossover": false,
    "crossover_temperature": null
  },
  "generations": [
    {
      "generation": 0,
      "solver_code": "import numpy as np\n\ndef solve(task_grid: np.ndarray) -> np.ndarray:\n    if task_grid.size == 0:\n        return task_grid\n\n    rows, cols = task_grid.shape\n    output_grid = np.copy(task_grid)\n    \n    # Find all non-zero cells\n    non_zero_coords = np.argwhere(task_grid != 0)\n    \n    if non_zero_coords.size == 0:\n        return output_grid\n\n    # Create a grid to store the closest non-zero color for each cell\n    # Initialize with a value indicating no color assigned yet\n    closest_color_grid = np.full((rows, cols), -1, dtype=int)\n    \n    # Initialize a queue for BFS with all non-zero cells and their colors\n    from collections import deque\n    queue = deque()\n    \n    for r, c in non_zero_coords:\n        color = task_grid[r, c]\n        queue.append(((r, c), color, 0)) # (coordinates, color, distance)\n        closest_color_grid[r, c] = color # Mark non-zero cells with their own color\n\n    # Perform BFS\n    while queue:\n        (r, c), color, dist = queue.popleft()\n\n        # Explore neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check boundaries\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # If the neighbor is a zero cell and hasn't been assigned a color yet\n                if task_grid[nr, nc] == 0 and closest_color_grid[nr, nc] == -1:\n                    closest_color_grid[nr, nc] = color\n                    queue.append(((nr, nc), color, dist + 1))\n                # If the neighbor is a zero cell and has been assigned a color,\n                # but this new path is shorter or equal distance (to handle simultaneous spread)\n                # This part is implicitly handled by BFS order if we prioritize shorter paths.\n                # However, the problem states \"filling outwards until they encounter another non-zero color\".\n                # This implies that if a zero cell is equidistant to two non-zero colors,\n                # the behavior might be undefined or depend on processing order.\n                # The BFS approach naturally assigns the color of the first encountered non-zero source.\n                # If a zero cell is already colored and we find a path of the same distance,\n                # we don't need to re-queue as it's already been processed.\n                # If a zero cell is already colored and we find a path of shorter distance,\n                # this BFS structure ensures we would have found it earlier.\n                # The key is that once a zero cell is colored, it's \"filled\".\n\n    # Update the output grid with the assigned colors for zero cells\n    # Cells that were originally non-zero remain unchanged.\n    # Cells that were zero and got assigned a color are updated.\n    # Cells that were zero and remained unassigned (e.g., if the grid was all zeros) will stay zero.\n    output_grid[task_grid == 0] = closest_color_grid[task_grid == 0]\n\n    return output_grid",
      "fitness_result": {
        "fitness": 0,
        "train_correct": 0,
        "train_total": 3,
        "test_correct": 0,
        "test_total": 1,
        "train_accuracy": 0.0,
        "test_accuracy": 0.0,
        "execution_errors": [],
        "error_details": [
          {
            "example_id": "train_0",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          },
          {
            "example_id": "train_1",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          },
          {
            "example_id": "train_2",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          },
          {
            "example_id": "test_0",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          }
        ],
        "error_summary": {
          "logic": 4
        }
      },
      "refinement_count": 0,
      "total_time": 4.317671060562134,
      "improvement": 0.0
    },
    {
      "generation": 1,
      "solver_code": "import numpy as np\nfrom collections import deque\n\ndef solve(task_grid: np.ndarray) -> np.ndarray:\n    if task_grid.size == 0:\n        return task_grid\n\n    rows, cols = task_grid.shape\n    output_grid = np.copy(task_grid)\n    \n    # Find all non-zero cells\n    non_zero_coords = np.argwhere(task_grid != 0)\n    \n    if non_zero_coords.size == 0:\n        return output_grid\n\n    # Create a grid to store the closest non-zero color for each cell\n    # Initialize with a value indicating no color assigned yet\n    # We use -1 to signify unassigned.\n    closest_color_grid = np.full((rows, cols), -1, dtype=int)\n    \n    # Initialize a queue for BFS with all non-zero cells and their colors\n    queue = deque()\n    \n    # For each non-zero cell, add it to the queue and mark its own position\n    for r, c in non_zero_coords:\n        color = task_grid[r, c]\n        queue.append(((r, c), color, 0)) # (coordinates, color, distance)\n        closest_color_grid[r, c] = color # Mark non-zero cells with their own color\n\n    # Perform BFS\n    while queue:\n        (r, c), color, dist = queue.popleft()\n\n        # Explore neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check boundaries\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # If the neighbor is a zero cell and hasn't been assigned a color yet\n                # OR if it has been assigned a color but this new path is shorter\n                # The BFS naturally handles shorter paths first.\n                # The condition `closest_color_grid[nr, nc] == -1` ensures we only\n                # process unassigned zero cells. Once a zero cell is assigned a color,\n                # it's considered \"filled\" by that color.\n                if task_grid[nr, nc] == 0 and closest_color_grid[nr, nc] == -1:\n                    closest_color_grid[nr, nc] = color\n                    queue.append(((nr, nc), color, dist + 1))\n\n    # Update the output grid with the assigned colors for zero cells.\n    # Cells that were originally non-zero remain unchanged because output_grid was initialized as a copy.\n    # Cells that were zero and got assigned a color are updated from closest_color_grid.\n    # Cells that were zero and remained unassigned (e.g., if the grid was all zeros or isolated zeros) will remain 0.\n    # We only update the cells that were originally zero.\n    zero_mask = (task_grid == 0)\n    output_grid[zero_mask] = closest_color_grid[zero_mask]\n\n    return output_grid",
      "fitness_result": {
        "fitness": 0,
        "train_correct": 0,
        "train_total": 3,
        "test_correct": 0,
        "test_total": 1,
        "train_accuracy": 0.0,
        "test_accuracy": 0.0,
        "execution_errors": [],
        "error_details": [
          {
            "example_id": "train_0",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          },
          {
            "example_id": "train_1",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          },
          {
            "example_id": "train_2",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          },
          {
            "example_id": "test_0",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          }
        ],
        "error_summary": {
          "logic": 4
        }
      },
      "refinement_count": 1,
      "total_time": 4.530441999435425,
      "improvement": 0.0
    },
    {
      "generation": 2,
      "solver_code": "import numpy as np\nfrom collections import deque\n\ndef solve(task_grid: np.ndarray) -> np.ndarray:\n    if task_grid.size == 0:\n        return task_grid\n\n    rows, cols = task_grid.shape\n    output_grid = np.copy(task_grid)\n    \n    # Find all non-zero cells\n    non_zero_coords = np.argwhere(task_grid != 0)\n    \n    if non_zero_coords.size == 0:\n        return output_grid\n\n    # Create a grid to store the closest non-zero color for each cell\n    # Initialize with a value indicating no color assigned yet.\n    # We use -1 to signify unassigned.\n    closest_color_grid = np.full((rows, cols), -1, dtype=int)\n    \n    # Initialize a queue for BFS with all non-zero cells and their colors\n    queue = deque()\n    \n    # For each non-zero cell, add it to the queue and mark its own position\n    for r, c in non_zero_coords:\n        color = task_grid[r, c]\n        queue.append(((r, c), color, 0)) # (coordinates, color, distance)\n        closest_color_grid[r, c] = color # Mark non-zero cells with their own color\n\n    # Perform BFS\n    while queue:\n        (r, c), color, dist = queue.popleft()\n\n        # Explore neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check boundaries\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # If the neighbor is a zero cell and hasn't been assigned a color yet\n                # The BFS naturally handles shorter paths first.\n                # We only process unassigned zero cells. Once a zero cell is assigned a color,\n                # it's considered \"filled\" by that color.\n                if task_grid[nr, nc] == 0 and closest_color_grid[nr, nc] == -1:\n                    closest_color_grid[nr, nc] = color\n                    queue.append(((nr, nc), color, dist + 1))\n\n    # Update the output grid with the assigned colors for zero cells.\n    # Cells that were originally non-zero remain unchanged because output_grid was initialized as a copy.\n    # Cells that were zero and got assigned a color are updated from closest_color_grid.\n    # Cells that were zero and remained unassigned (e.g., if the grid was all zeros or isolated zeros) will remain 0.\n    # We only update the cells that were originally zero.\n    zero_mask = (task_grid == 0)\n    output_grid[zero_mask] = closest_color_grid[zero_mask]\n\n    return output_grid",
      "fitness_result": {
        "fitness": 0,
        "train_correct": 0,
        "train_total": 3,
        "test_correct": 0,
        "test_total": 1,
        "train_accuracy": 0.0,
        "test_accuracy": 0.0,
        "execution_errors": [],
        "error_details": [
          {
            "example_id": "train_0",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          },
          {
            "example_id": "train_1",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          },
          {
            "example_id": "train_2",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          },
          {
            "example_id": "test_0",
            "error_type": "logic",
            "error_message": "Output does not match expected result",
            "exception_class": null
          }
        ],
        "error_summary": {
          "logic": 4
        }
      },
      "refinement_count": 1,
      "total_time": 4.044577121734619,
      "improvement": 0.0
    }
  ],
  "final_fitness": 0,
  "total_generations": 3,
  "total_time": 12.892690181732178
}
